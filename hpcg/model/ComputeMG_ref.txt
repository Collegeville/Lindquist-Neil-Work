operations
	1x fill vector with 0's
	1x access struct field
	1x compare accumulator, 0
	#if A.mgData == 0 (if next coarse level is not defined)
		1x call ComputeSYMGS_ref
	#else
		6x access struct field
		2x store int to counter
		3x compare accumulator, 0
		1x call ComputeRestriction_ref
		1x call ComputeProlongation_ref
		1x recurse to next coarse level
		loop numberOfPresmootherSteps+numberOfPostsmootherSteps times:
			1x compare counter, int
			1x incr counter
			1x call ComputeSYMGS_ref
			1x add
			1x load int from accumulator
			1x store int to accumulator
	#end if
	
	
bytes loaded (excluding counters and accumulators, assuming all pointers are the same size)
	
	bytesLoaded(ComputeSYMGS_ref)
	*(1 
		+ numberOfCoarseLevels
		*(numberOfPresmootherSteps+numberOfPostsmootherSteps))
	
	+ numberOfCoarseLevels
		*(bytesLoaded(ComputeRestriction_ref)
		+ bytesLoaded(ComputeProlongation_ref))
		
	= (3*sizeof(void*) + sizeof(local_int_t)
		+ nrow*(4*sizeof(void*) + 2*sizeof(int) + 4*sizeof(<datatype>))
		+ nnz*(2*sizeof(local_int_t) + 4*sizeof(<datatype>)))
	*(1
		+ numberOfCoarseLevels
		*(numberOfPresmootherSteps+numberOfPostsmootherSteps))
	+ numberOfCoarseLevels
		*((4*sizeof(void*) + sizeof(local_int_t)
			+ nc*(sizeof(local_int_t) + 2*sizeof(<datatype>)))
		+ (3*sizeof(void*) + sizeof(local_int_t)
			+ nc*(sizeof(local_int_t) + 2*sizeof(<datatype>))))
	
	= (3*sizeof(void*) + sizeof(local_int_t)
		+ nrow*(4*sizeof(void*) + 2*sizeof(int) + 4*sizeof(<datatype>))
		+ nnz*(2*sizeof(local_int_t) + 4*sizeof(<datatype>)))
	*(1
		+ numberOfCoarseLevels
		*(numberOfPresmootherSteps+numberOfPostsmootherSteps))
	+ numberOfCoarseLevels
		*((7*sizeof(void*) + 2*sizeof(local_int_t)
			+ 2*nc*(sizeof(local_int_t) + 2*sizeof(<datatype>))))
		
		
	calculated for actual setup (sizeof(void*) -> 8 bytes, sizeof(local_int_t) -> sizeof(int) -> 4 bytes)
		(28 + nrow*(40 + 4*sizeof(<datatype>)) + nnz*(8 + 4*sizeof(<datatype>)))
		*(1
			+ numberOfCoarseLevels
			*(numberOfPresmootherSteps+numberOfPostsmootherSteps))
		+ numberOfCoarseLevels
			*(64 + nc*(8 + 4*sizeof(<datatype>)))
			
		with 32-bit floats
			(28 + 56*nrow + 24*nnz)
			*(1
				+ numberOfCoarseLevels
				*(numberOfPresmootherSteps+numberOfPostsmootherSteps))
			+ numberOfCoarseLevels
				*(64 + 24*nc)
			
			≈ numberOfCoarseLevels
			*((28 + 56*nrow + 24*nnz)
				*(numberOfPresmootherSteps+numberOfPostsmootherSteps)
				+ 64 + 24*nc)
			
			≈ numberOfCoarseLevels
			*((340/13)*nnz
				*(numberOfPresmootherSteps+numberOfPostsmootherSteps)
				+ 24*nc)
		with 64-bit floats
			(28 + 72*nrow + 40*nnz)
			*(1
				+ numberOfCoarseLevels
				*(numberOfPresmootherSteps+numberOfPostsmootherSteps)
			+ numberOfCoarseLevels
				*(64 + 40*nc)
				
			≈ numberOfCoarseLevels
			*((28 + 72*nrow + 40*nnz)
				*(numberOfPresmootherSteps+numberOfPostsmootherSteps)
				+ 64 + 40*nc)
				
			≈ numberOfCoarseLevels
			*((556/13)*nnz
				*(numberOfPresmootherSteps+numberOfPostsmootherSteps)
				+ 40*nc)
			
				
		theoretical  - ~38.85% decrease
