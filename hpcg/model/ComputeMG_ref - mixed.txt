templated: <datatype>

NOTE: ComputeMG_ref<double> is equivalent to the implementation for pure double-precision data
NOTE: ComputeMG_ref<float> is not currently used in the mixed implementation, so I'm not going to bother calculating it


bytes loaded (excluding counters and accumulators, assuming all pointers are the same size, A_n is the nth coarse-ified version of the matrix)

	2*sizeof(int)
	+ bytesLoaded(ComputeSPMV_ref<double>(A_0))
	+ bytesLoaded(ComputeRestriction_ref<datatype>(A_0))
	+ bytesLoaded(ComputeProlongation_ref(A_0))
	+ (numberOfPresmootherSteps+numberOfPostsmootherSteps)*bytesLoaded(ComputeSYMGS_ref<datatype>(A_0))

	+ 2*sizeof(int)
	+ bytesLoaded(ComputeSPMV_ref<double>(A_1))
	+ bytesLoaded(ComputeRestriction_ref<double>(A_1))
	+ bytesLoaded(ComputeProlongation_ref(A_1))
	+ (numberOfPresmootherSteps+numberOfPostsmootherSteps)*bytesLoaded(ComputeSYMGS_ref<double>(A_1))

	+ 2*sizeof(int)
	+ bytesLoaded(ComputeSPMV_ref<double>(A_2))
	+ bytesLoaded(ComputeRestriction_ref<double>(A_2))
	+ bytesLoaded(ComputeProlongation_ref(A_2))
	+ (numberOfPresmootherSteps+numberOfPostsmootherSteps)*bytesLoaded(ComputeSYMGS_ref(A_2))

	+ 2*sizeof(int)
	+ bytesLoaded(ComputeSYMGS_ref<double>(A_3))
