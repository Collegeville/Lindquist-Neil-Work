\documentclass{article}

\usepackage{listings}

\title{Optimization of Julia Petra}
\author{Neil Lindquist}

\newcommand{\juliaSnippet}[1]{\lstinline{#1}}
\newcommand{\cSnippet}[1]{\lstinline[]{#1}}

\begin{document}
	
\section{Type Stability}
Probably the most significant area of optimization in juliaPetra is ensuring Type Stability of the methods.
Because Julia is a dynamic language, it must dispatch all method calls and operators unless it can
determine the exact types of the related variables.  This includes ``fundamental'' operations like array indexing and addition.
Towards this end, Julia will compile multiple versions of a method for different argument types.
Julia's type inferencer generally can figure out the types of variables, although it struggles on a few
corner cases.
%TODO give examples. `typeof(rowInfoCache) == RowInfo{LID}`?  type unions and method return values?  explicit integers?

As a dynamic language that is still quite young, improving type stability in Julia does suffer from poor tooling.
The only tool for analyzing the type stability of Julia code is the \juliaSnippet{@code_warntype} macro.
This macro takes a function and an argument list and outputs type annotated, ``lowered'' code, which is the code
after macros and inlining have been applied and after flow control has been converted into goto statements, and
non-concrete types are highlighted in red.  This means that to check the type stability of a method, the
programmer must look at a low level version of the method, for each set of argument types, and look for red types.
I ended up designing a few utility functions and macros to help me check type stability automatically for
a series of argument types.

\section{Garbage Reduction}
Julia is a garbage collected language, with no means create a object not under the control of the garbage collector.
By using an object pool for \juliaSnippet{RowInfo} objects, which are used in the matrix-vector multiplication loop, I was able to reduce the amount of garbage collection.
%However, the call overhead for the object pool does use up a good portion of the savings?
%TODO provide hard evidence of improvement

Another tool I used to reduce garbage collection was to use pointer's to array locations instead of a full \juliaSnippet{SubView} object.
This reduced the size of the array view to a pointer and length integer and allowed the values to become stack variables instead of heap objects.
Using pointers instead of references to the array or view objects does remove bounds checking, but much of that would be eliminated by
\juliaSnippet{@inbounds} annotations anyways in critical sections.
The main issues with pointers is duplication between the fast, internal method and the Julian, external method.

\section{Function Inlining}
When profiling, a significant amount of time was spend in ``line 0'' of various files.
I realized that this was method call and dispatch overhead.
I was able to eliminate much of that time by aggressively inlining functions that are called within the matrix-vector multiplication loop.
This speed up likely does come at the cost of increased code size, depending on how many different function's reference the inlined methods
%TODO provide hard evidence of improvement


\end{document}