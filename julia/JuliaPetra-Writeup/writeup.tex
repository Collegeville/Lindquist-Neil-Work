\documentclass[acmsmall]{acmart}
\bibliographystyle{ACM-Reference-Format}

\title{Implementation of Petra in Julia}
\author{Neil Lindquist}

\newcommand{\juliaSnippet}[1]{\texttt{\detokenize{#1}}}

\begin{document}

\maketitle

\section{Introduction}

Julia is a programing language first publicly released in 2012 \cite{WhyWeCreatedJulia}.
Julia is designed so that it
``has the performance of a statically compiled
language while providing interactive dynamic behavior and productivity like Python, LISP or
Ruby'' \cite{JuliaDesignPaper}.
%TODO look into referencing use in HPC (celeste/petaflop club?)
	%Can't find any formal papers, https://juliacomputing.com/case-studies/celeste.html is the closest

%REVIEW go into more detail?
The Petra Object Model is the design used in Trilinos for objects commonly used in solver algorithms.
\cite{OverviewOfTrilinos}
Petra libraries provide parallel, distributed matrices, vectors and graphs for other packages to use.

JuliaPetra is an implementation of the Petra Object model in Julia.
A similar project exists in the Trilinos.jl project, which is a Julia wrapper for select parts of
the Trilinos C++ library \cite{Trilinos.jlGithub}.
JuliaPetra is different in that it is build entirely in Julia, with the exception of the
native libraries used by MPI.jl.

%TODO talk about goal of paper/JuliaPetra

\section{Implementation of JuliaPetra}

\subsection{Design of JuliaPetra}

The design of JuliaPetra follows closely with that of ePetra and tPetra.
In particular, the communication APIs, such as \juliaSnippet{Comm} and \juliaSnippet{BlockMap}
are based off ePetra and the data structures, such as \juliaSnippet{MultiVector} and
\juliaSnippet{RowMatrix} are based off tPetra.


%TODO talk about what is and isn't ideomatic Julia
JuliaPetra is somewhat idiomatic Julia code, however, there are some areas that are closer to
idiomatic C/C++ code.
One less than idiomatic area has to do with the fact that JuliaPetra is built using the MPI
single-program-multiple-data model, where the same program is run on multiple processes
that communicate with each other.
%TODO figure out citations
The parallel model that comes built-in to Julia, on the other hand, has a main process that
asynchronously evaluates long running functions on other processes.  \cite{JuliaFreshApproach}
%TODO talk a bit about the differences in program logic?
%TODO mention that each process iterates over only the local part, not the entirety

JuliaPetra's type hierarchy is built on top of Julia's AbstractArray type.  This improves
interaction between JuliaPetra and existing Julia code.
Since Julia doesn't support multiple inheritance, %TODO cite?
other interfaces are implemented without a type.
These interfaces include ePetra's Operator, SrcDistObject and DistObject.
So, any methods that use one of those types accepts any object and assumes
the methods required for the interface are present.

\subsection{Optimizing JuliaPetra}

Type stability was one of the most important factors in improving the speed of JuliaPetra.
A function is type stable if the type inferencer is able to deduce that a variable will only
hold objects of a specific, concrete type.
%REVIEW figure out if I need a cite on the definition of Type Stability
When the type inferencer is able to infer a variable's type well enough that only a single
method matches for a particular function call, that method call may be inlined. \cite{JuliaDesignPaper}
This removes method dispatch and call overhead at run time.
Additionally, even if the method is not inlined for other reasons, the specific method that should
be called is known already so it doesn't need to be found at run time.
This process is able to work well for any set of arguments, since each function is compiled
separately for every set of concrete types for which it is applied.  \cite{JuliaFreshApproach}

Given the importance of Type Stability for high performance Julia code, it is important it be able
to determine if a critical section of code is type stable.
However, the only tool Julia provides for checking type stability is the \juliaSnippet{code_warntype}
function and the related \juliaSnippet{@code_warntype} macro.  This function takes a function and list
of types and outputs a version of the function for arguments of the given types after some optimizations
have occurred and marks non-concrete types, likely indicators of type unstable code, in red.
This requires manually checking a function for each combination of argument types that should be optimized.
Furthermore, there are not any tools provided by the Julia community to make checking type stability easier.
So, to ensure important functions were type stable for important sets of arguments,
extra utilities needed to be written to check the type stability automatically.
%TODO call it out as the "TypeStability.jl package"?  Should look into publishing it publicly

In the matrix vector multiplication loop, there is a lot of use for getting a view of a chunk of an array.
However, creating an actual array view object requires allocating to the heap, and thus garbage collection.
The work around used in JuliaPetra at various internal locations is to use the \juliaSnippet{Ptr} API.
The \juliaSnippet{Ptr} API is designed for interacting with C libraries, however it allows creating
a \juliaSnippet{Ptr} that points to location an array and dereferencing elements in that array.
As bits types, \juliaSnippet{Ptr} objects and integers are able to be stack allocated.
Additionally, \juliaSnippet{Tuple} objects are optimized so that they can be stack allocated.
Thus, by representing a view of an array as a \juliaSnippet{(Ptr, Integer)} tuple, the view
can be stack allocated, meaning it does not need to be garbage collected.
This improves the speed of the matrix vector multiplication loop.
%TODO figure out what should be cited from where in this paragraph

Another optimization was use of the \juliaSnippet{@inline} macro, which indicates to the
compiler that the annotated function should be inlined.
This ensures that functions that are used in performance critical functions do not have
method call overhead.
%REVIEW does this really need to be a paragraph?  It seems like kind of a basic thing, force critical functions to be inlined

\section{Comparisons with Other Distributed Libraries}

\subsection{Comparing with ePetra}

JuliaPetra is fairly similar to ePetra, as ePetra was used as the template for implementing JuliaPetra.

The JuliaPetra and ePetra implementations of the power method are similar, due to the similarities
in the APIs and the simplicity of the algorithm.
JuliaPetra was able to achieve the same performance as ePetra on large instances of the power method,
as can be seen in the Results section.
Since Julia uses just in time compiling exclusively, it has extra start up costs compared to
the ePetra version. However, since each specialized method needs to be compiled only once,
this is a fixed cost.

\subsection{Comparing with DistributedArrays.jl}

DistributedArrays.jl is a similar library designed to support distributed arrays in parallel environments.
\cite{DAGithub}
%TODO talk about general design
DistributedArrays.jl is designed for Julia's built in parallel model, so operations that apply to
each element are distributed to each process from the master process.
DistributedArrays.jl offers a number of advantages over JuliaPetra, however, it is not able to
match the speed of JuliaPetra.

One area where DistributedArrays.jl has an advantage over Julia is that it follows standard
practice for ideomatic Julia code more than JuliaPetra.
For example, it is built around the default Julia parallelization model and APIs.
It's APIs are all designed as function calls that should be made from a main process that
then delegates part of the work to the other processes. %TODO remove?
%TODO comment how DA fits a little better with Array APIS
	%does it majorly?
Another advantage is that DistributedArrays.jl uses an instance of \juliaSnippet{AbstractArray}
for a process's local storage, this allows automatic support for different array structures.

However, DistributedArrays.jl was not able to match the speed of JuliaPetra.
It was able to get within twice the time of JuliaPetra, but was never able to get within 1.5 times
the execution time of JuliaPetra.

\section{Results}

%TODO show timing data

%TODO discuss methodology used to get data
The timing results were obtained by running the various power method implementaitons
with various sized problems and varying numbers of processors.
Each combination of problem size and number of processors was run five times.
Tests were ran with Julia v0.6.0 and Trilinos 12.10.1.
%TODO add OS & such
%TODO anything else that should be described?


\section{Conclusion}

JuliaPetra is an implementation of the Petra object model in the Julia programming language.
JuliaPetra is able to perform at the same speeds as ePetra.
There are aspects of JuliaPetra that are not ideomatic Julia code, however, JuliaPetra has much
better performance than the more ideomatic DistributedArrays.jl.

%This shows that...?

\bibliography{bibliography}
\end{document}